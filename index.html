<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Emoji Downhill</title>

<link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    background: #8abfff;
    font-family: 'Silkscreen', monospace;
  }

  * {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    -webkit-user-select: none;
    user-select: none;
  }

  html, body, canvas { touch-action: none; }

  #pixel-transition {
    position: fixed;
    inset: 0;
    z-index: 19;
    display: none;
    image-rendering: pixelated;
    pointer-events: none;
  }

  #pause-inner { text-align: center; }

  #start-screen {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 15;
    color: #f5fbff;
    background: radial-gradient(circle at top, #283a63 0%, #050818 55%, #02030a 100%);
    overflow: hidden;
  }

  #game-over {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
    color: #f5fbff;
    background: radial-gradient(circle at top, #283a63 0%, #050818 55%, #02030a 100%);
    overflow: hidden;
  }
  #game-over.visible { display: flex; }

  #start-screen::before,
  #start-screen::after,
  #game-over::before,
  #game-over::after {
    content: "";
    position: absolute;
    top: 0; left: 0;
    width: 2px;
    height: 2px;
    background: #ffffff;
    image-rendering: pixelated;
    z-index: 0;
  }

  #start-screen::before,
  #game-over::before {
    opacity: 0.7;
    box-shadow:
      20vw 10vh 0 0 #ffffff,
      40vw 15vh 0 0 #ffffff,
      70vw 8vh 0 0 #ffffff,
      15vw 30vh 0 0 #ffffff,
      55vw 28vh 0 0 #ffffff,
      80vw 24vh 0 0 #ffffff,
      10vw 50vh 0 0 #ffffff,
      35vw 45vh 0 0 #ffffff,
      65vw 52vh 0 0 #ffffff,
      85vw 38vh 0 0 #ffffff,
      25vw 70vh 0 0 #ffffff,
      50vw 65vh 0 0 #ffffff,
      75vw 72vh 0 0 #ffffff,
      15vw 85vh 0 0 #ffffff,
      60vw 88vh 0 0 #ffffff;
    animation: twinkle 4.5s infinite alternate;
  }

  #start-screen::after,
  #game-over::after {
    opacity: 0.9;
    box-shadow:
      8vw  18vh 0 0 #ffffff,
      28vw 12vh 0 0 #ffffff,
      52vw 20vh 0 0 #ffffff,
      78vw 16vh 0 0 #ffffff,
      18vw 40vh 0 0 #ffffff,
      42vw 36vh 0 0 #ffffff,
      68vw 32vh 0 0 #ffffff,
      90vw 44vh 0 0 #ffffff,
      5vw  60vh 0 0 #ffffff,
      32vw 58vh 0 0 #ffffff,
      58vw 62vh 0 0 #ffffff,
      82vw 68vh 0 0 #ffffff,
      22vw 80vh 0 0 #ffffff,
      48vw 82vh 0 0 #ffffff,
      72vw 86vh 0 0 #ffffff;
    animation: twinkle 3.2s infinite alternate;
  }

  .mountain-band {
    position: absolute;
    bottom: -20px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 140px;
    line-height: 1;
    pointer-events: none;
    z-index: 1;
    white-space: nowrap;
    overflow: hidden;
  }

  #start-inner,
  #game-over-inner {
    position: relative;
    z-index: 2;
    text-align: center;
    padding: 24px 32px;
  }

  .ice-title {
    position: relative;
    display: inline-block;
    text-transform: uppercase;
    font-size: clamp(44px, 8vw, 90px);
    line-height: 0.92;
    letter-spacing: clamp(2px, 0.7vw, 6px);
    padding: 10px 20px;

    background-image: linear-gradient(
      180deg,
      #ffffff 0%,
      #e9f7ff 35%,
      #c8e7ff 60%,
      #7eb8e6 100%
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;

    text-shadow:
      0 4px 0 #4b6d8c,
      0 6px 10px rgba(0, 0, 0, 0.7);
  }

  .ice-line { display: block; }

  .ice-title .pix {
    position: absolute;
    width: 3px;
    height: 3px;
    background: #fff;
    image-rendering: pixelated;
    box-shadow:
      0 -3px 0 rgba(255,255,255,0.9),
      0  3px 0 rgba(255,255,255,0.9),
      -3px 0 0 rgba(255,255,255,0.9),
      3px 0 0 rgba(255,255,255,0.9);
    opacity: 0.8;
    animation: twinkle 1.2s infinite alternate;
  }

  .pix-1 { top: 18%; left: 18%; }
  .pix-2 { top: 12%; left: 62%; }
  .pix-3 { top: 34%; left: 30%; }
  .pix-4 { top: 48%; left: 74%; }
  .pix-5 { top: 70%; left: 42%; }
  .pix-6 { top: 62%; left: 12%; }
  .pix-7 { top: 20%; left: 82%; }

  @keyframes twinkle {
    0%   { transform: scale(1); opacity: 0.4; }
    100% { transform: scale(1.3); opacity: 1; }
  }

  #start-inner p { font-size: 18px; margin: 4px 0 24px; }

  .mode-buttons {
    display: flex;
    gap: 24px;
    justify-content: center;
  }

  .mode-btn {
    padding: 16px 28px;
    border-radius: 20px;
    border: 2px solid #f5fbff;
    background: #ffffff10;
    color: #f5fbff;
    cursor: pointer;
    min-width: 220px;
    font-family: 'Silkscreen', monospace;
    font-size: 18px;
    transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s;
    backdrop-filter: blur(4px);
  }

  .mode-btn span.big {
    display: block;
    font-size: 32px;
    margin-bottom: 6px;
  }

  .mode-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 0 #00000066;
    background: #ffffff22;
  }

  .mode-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 0 #00000066;
  }

  .mode-btn.selected {
    background: #ffffff33;
    box-shadow: 0 6px 0 #00000099;
    transform: translateY(-3px);
  }

  #legend {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.9);
    border-radius: 999px;
    padding: 6px 16px;
    font-size: 14px;
    z-index: 5;
  }

  #hud-distance-bar,
  #hud-best-bar {
    position: fixed;
    top: 10px;
    background: rgba(255,255,255,0.9);
    border-radius: 999px;
    padding: 6px 16px;
    font-size: 14px;
    z-index: 5;
    white-space: nowrap;
  }

  #hud-distance-bar { left: 10px; }
  #hud-best-bar    { right: 10px; }

  .go-legend-text {
    font-size: 18px;
    color: #f5fbff;
    margin-top: 12px;
    margin-bottom: 24px;
  }

  #restart-btn { margin-top: 20px; }

  #pause-overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 18;
    background: rgba(0,0,0,0.90);
    color: #f5fbff;
    pointer-events: none;
  }
  #pause-overlay.visible { display: flex; }

  @media (max-width: 700px), (pointer: coarse) {
    #start-inner, #game-over-inner { padding: 18px 16px; }
    .ice-title { padding: 6px 10px; }

    .mode-buttons {
      flex-direction: column;
      align-items: center;
      gap: 14px;
    }

    .mode-btn {
      min-width: 0;
      width: min(92vw, 360px);
      padding: 14px 18px;
      border-radius: 18px;
      font-size: 16px;
    }

    .mode-btn span.big { font-size: 26px; }

    #legend { display: none; }
    .mountain-band { display: none; }
  }
</style>
</head>

<body>
<canvas id="game"></canvas>
<canvas id="pixel-transition"></canvas>

<div id="hud-distance-bar"><span id="hud-distance">DISTANCE: 0m</span></div>
<div id="hud-best-bar"><span id="hud-best">BEST: 0m</span></div>

<audio id="bg-menu" loop><source src="pixelate-pixelated-dreams-313358.mp3" type="audio/mpeg"></audio>
<audio id="bg-music-1" class="bg-music" loop><source src="music-1.mp3" type="audio/mpeg"></audio>
<audio id="bg-music-2" class="bg-music" loop><source src="music-2.mp3" type="audio/mpeg"></audio>
<audio id="bg-music-3" class="bg-music" loop><source src="music-3.mp3" type="audio/mpeg"></audio>

<audio id="sfx-explosion"><source src="8-bit-explosion-3-340456.mp3" type="audio/mpeg"></audio>
<audio id="sfx-pause"><source src="pause.mp3" type="audio/mpeg"></audio>
<audio id="sfx-step"><source src="step.mp3" type="audio/mpeg"></audio>
<audio id="sfx-click"><source src="click.mp3" type="audio/mpeg"></audio>

<div id="start-screen">
  <div class="mountain-band">üóªüóªüóªüóªüóªüóªüóªüóªüóªüóªüóªüóª</div>

  <div id="start-inner">
    <h1 class="ice-title">
      <span class="ice-line">MOUNT EMOJI</span>
      <span class="ice-line">DOWNHILL</span>
      <span class="pix pix-1"></span><span class="pix pix-2"></span><span class="pix pix-3"></span>
      <span class="pix pix-4"></span><span class="pix pix-5"></span><span class="pix pix-6"></span><span class="pix pix-7"></span>
    </h1>

    <div id="mode-select" class="mode-buttons">
      <button id="btn-1p" class="mode-btn"><span class="big">SINGLE RIDER</span></button>
      <button id="btn-2p" class="mode-btn"><span class="big">RIDER VS RIDER</span></button>
    </div>

    <div id="char-select" class="mode-buttons" style="display:none;">
      <button id="btn-char-snowboarder" class="mode-btn"><span class="big">üèÇ SNOWBOARDER</span></button>
      <button id="btn-char-skier" class="mode-btn"><span class="big">‚õ∑Ô∏è SKIER</span></button>
    </div>

    <br><br>
    <p id="start-legend">PLAYER 1: Arrow keys &nbsp;|&nbsp; PLAYER 2: A / D</p>

    <br><br><br>
    <p>¬© emoji games</p>
  </div>
</div>

<div id="legend">Player 1: Arrow keys &nbsp;|&nbsp; Player 2: A / D</div>

<div id="game-over">
  <div class="mountain-band">üóªüóªüóªüóªüóªüóªüóªüóªüóªüóªüóªüóª</div>

  <div id="game-over-inner">
    <h1 class="ice-title game-over-title">
      <span class="ice-line">GAME</span>
      <span class="ice-line">OVER</span>
      <span class="pix pix-1"></span><span class="pix pix-2"></span><span class="pix pix-3"></span>
      <span class="pix pix-4"></span><span class="pix pix-5"></span><span class="pix pix-6"></span><span class="pix pix-7"></span>
    </h1>

    <p id="result-text" class="go-legend-text">you made it 0 meters</p>

    <button id="restart-btn" class="mode-btn">
      <span class="big">‚Üª GET BACK UP</span>
    </button>
  </div>
</div>

<div id="pause-overlay">
  <div id="pause-inner">
    <h1 class="ice-title">
      <span class="ice-line">PAUSED</span>
      <span class="pix pix-1"></span><span class="pix pix-2"></span><span class="pix pix-3"></span>
      <span class="pix pix-4"></span><span class="pix pix-5"></span><span class="pix pix-6"></span><span class="pix pix-7"></span>
    </h1>
    <p class="go-legend-text">press any key to continue</p>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const pixelCanvas = document.getElementById("pixel-transition");
const pctx = pixelCanvas.getContext("2d");

canvas.addEventListener("contextmenu", (e) => e.preventDefault());
canvas.addEventListener("dragstart", (e) => e.preventDefault());
canvas.addEventListener("selectstart", (e) => e.preventDefault());
document.addEventListener("touchmove", (e) => {
  if (e.target === canvas) e.preventDefault();
}, { passive: false });

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  pixelCanvas.width = window.innerWidth;
  pixelCanvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

function drawSolidBackground() {
  ctx.fillStyle = "#D9E5F4";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function isSmallScreen() {
  return window.matchMedia("(max-width: 700px), (pointer: coarse)").matches;
}
let smallScreen = isSmallScreen();

// EASY MOBILE TUNING (EDIT THESE)
const DESKTOP_CLUSTER_BASE = 3;
const DESKTOP_CLUSTER_EXTRA_CAP = 7;
const DESKTOP_CLUSTER_RAND_MAX = 1;

/* ‚úÖ MOBILE: ALWAYS 1 TREE PER "CLUSTER" */
const MOBILE_CLUSTER_BASE = 1;
const MOBILE_CLUSTER_EXTRA_CAP = 0;
const MOBILE_CLUSTER_RAND_MAX = 0;

const DESKTOP_SPAWN_BASE = 0.03;
const DESKTOP_SPAWN_RAMP = 0.003;
const DESKTOP_SPAWN_CAP  = 0.35;

const MOBILE_SPAWN_BASE = 0.022;
const MOBILE_SPAWN_RAMP = 0.0022;
const MOBILE_SPAWN_CAP  = 0.26;

// Players
const skier = {
  id: "P1",
  label: "Skier",
  baseEmoji: "‚õ∑Ô∏è",
  emoji: "‚õ∑Ô∏è",
  x: canvas.width / 2 - 80,
  y: 200,
  size: 60,
  lastX: null,
  crashed: false,
  crashMeters: 0,
  facingRight: false
};
const snowboarder = {
  id: "P2",
  label: "Snowboarder",
  baseEmoji: "üèÇ",
  emoji: "üèÇ",
  x: canvas.width / 2 + 80,
  y: 200,
  size: 60,
  lastX: null,
  crashed: false,
  crashMeters: 0,
  facingRight: false
};

// Speeds
const SKI_SPEED_DESKTOP = 480;
const SKI_SPEED_MOBILE  = 420;
const SNOWBOARD_SPEED_DESKTOP = 480;
const SNOWBOARD_SPEED_MOBILE  = 420;
const TREE_SPEED_DESKTOP = 720;
const TREE_SPEED_MOBILE  = 620;
const CRASH_SLIDE_SPEED_DESKTOP = 720;
const CRASH_SLIDE_SPEED_MOBILE  = 620;

function getSkiSpeed()        { return smallScreen ? SKI_SPEED_MOBILE : SKI_SPEED_DESKTOP; }
function getSnowboardSpeed()  { return smallScreen ? SNOWBOARD_SPEED_MOBILE : SNOWBOARD_SPEED_DESKTOP; }
function getTreeSpeed()       { return smallScreen ? TREE_SPEED_MOBILE : TREE_SPEED_DESKTOP; }
function getCrashSlideSpeed() { return smallScreen ? CRASH_SLIDE_SPEED_MOBILE : CRASH_SLIDE_SPEED_DESKTOP; }

const TARGET_Y_DESKTOP = 200;
const TARGET_Y_MOBILE  = 150;
function getTargetY() { return smallScreen ? TARGET_Y_MOBILE : TARGET_Y_DESKTOP; }

let activePlayers = [];
let mode = null;
let gameStarted = false;

let obstacles = [];
let startTime = null;
let currentTimeSec = 0;
let gameOver = false;

let snowParticles = [];

let runEnded = false;
let freezeTimeSec = 0;
let pendingGameOverTime = 0;

let introSliding = false;
let introSlideStart = 0;
const introSlideDuration = 800;

let paused = false;
let pausedAt = 0;
let pausedAccum = 0;

let lastFrameTime = null;
let spawnTimer = 0;
let transitioningToGame = false;

// UI
const startScreen = document.getElementById("start-screen");
const btn1P = document.getElementById("btn-1p");
const btn2P = document.getElementById("btn-2p");
const restartBtn = document.getElementById("restart-btn");
const hudDistanceEl = document.getElementById("hud-distance");
const gameOverOverlay = document.getElementById("game-over");
const resultTextEl = document.getElementById("result-text");
const pauseOverlay = document.getElementById("pause-overlay");

const modeSelectRow = document.getElementById("mode-select");
const charSelectRow = document.getElementById("char-select");
const btnCharSkier = document.getElementById("btn-char-skier");
const btnCharSnowboarder = document.getElementById("btn-char-snowboarder");
const startLegendEl = document.getElementById("start-legend");

// Music
const menuMusicEl = document.getElementById("bg-menu");
function playMenuMusic() {
  if (!menuMusicEl) return;
  menuMusicEl.volume = 0.4;
  if (menuMusicEl.paused) menuMusicEl.play().catch(() => {});
}
function pauseMenuMusic() { if (menuMusicEl) menuMusicEl.pause(); }
function restartMenuMusic() {
  if (!menuMusicEl) return;
  menuMusicEl.pause();
  menuMusicEl.currentTime = 0;
  playMenuMusic();
}

// Gameplay music
const musicTracks = [
  document.getElementById("bg-music-1"),
  document.getElementById("bg-music-2"),
  document.getElementById("bg-music-3")
];
let currentMusicIndex = 0;
function getCurrentMusicEl() { return musicTracks[currentMusicIndex] || null; }
function playMusic() {
  const el = getCurrentMusicEl();
  if (!el) return;
  el.volume = 0.4;
  if (el.paused) el.play().catch(() => {});
}
function pauseMusic() { const el = getCurrentMusicEl(); if (el) el.pause(); }
function restartMusic() {
  const el = getCurrentMusicEl();
  if (!el) return;
  el.pause();
  el.currentTime = 0;
  playMusic();
}

// SFX
const explosionEl = document.getElementById("sfx-explosion");
function playExplosion() {
  if (!explosionEl) return;
  explosionEl.currentTime = 0;
  explosionEl.volume = 0.8;
  explosionEl.play().catch(() => {});
}
const pauseSfx = document.getElementById("sfx-pause");
const stepSfx  = document.getElementById("sfx-step");
const clickSfx = document.getElementById("sfx-click");
function playPauseSfx() { if (pauseSfx) { pauseSfx.currentTime = 0; pauseSfx.play().catch(() => {}); } }
function playStepSfx()  { if (stepSfx)  { stepSfx.currentTime = 0; stepSfx.play().catch(() => {}); } }
function playClickSfx() { if (clickSfx) { clickSfx.currentTime = 0; clickSfx.play().catch(() => {}); } }

// Mobile menu behavior
function applyMenuForScreenSize() {
  smallScreen = isSmallScreen();
  if (smallScreen) {
    startLegendEl.textContent = "TAP LEFT/RIGHT SIDE TO STEER";
    modeSelectRow.style.display = "none";
    charSelectRow.style.display = "flex";
  } else {
    startLegendEl.textContent = "PLAYER 1: Arrow keys | PLAYER 2: A / D";
    modeSelectRow.style.display = "flex";
    charSelectRow.style.display = "none";
  }
}
applyMenuForScreenSize();
window.addEventListener("resize", applyMenuForScreenSize);

// Start selection
function startSinglePlayer(character) {
  mode = "1P";
  activePlayers = [character === "skier" ? skier : snowboarder];
  activePlayers[0].x = canvas.width / 2;
  startGame();
}

btnCharSkier.addEventListener("click", () => { playClickSfx(); startSinglePlayer("skier"); });
btnCharSnowboarder.addEventListener("click", () => { playClickSfx(); startSinglePlayer("snowboarder"); });
btn1P.addEventListener("click", () => { playClickSfx(); });
btn2P.addEventListener("click", () => { playClickSfx(); });

// Start game
function startGameCore() {
  gameStarted = true;
  startTime = null;
  obstacles = [];
  snowParticles = [];
  gameOver = false;

  runEnded = false;
  freezeTimeSec = 0;
  pendingGameOverTime = 0;

  paused = false;
  pausedAt = 0;
  pausedAccum = 0;

  spawnTimer = 0;
  lastFrameTime = null;
  pauseOverlay.classList.remove("visible");

  [skier, snowboarder].forEach(p => {
    p.emoji = p.baseEmoji;
    p.crashed = false;
    p.crashMeters = 0;
    p.lastX = null;
    p.facingRight = false;
    p.y = -150;
  });

  introSlideStart = performance.now();
  introSliding = true;
}

function startGame() {
  if (transitioningToGame) return;
  transitioningToGame = true;

  pauseMenuMusic();
  restartMusic();

  startPixelTransition(() => {
    startScreen.style.display = "none";
    startGameCore();
    transitioningToGame = false;
  });
}

// Input
const keys = {};
let touchDir = 0;
let touchActive = false;

function updateTouchDirFromEvent(e) {
  if (!smallScreen) return;
  if (!gameStarted || gameOver || paused || runEnded) return;

  const x = e.clientX ?? (e.touches && e.touches[0] && e.touches[0].clientX);
  if (typeof x !== "number") return;

  touchDir = (x < canvas.width / 2) ? -1 : 1;
}

canvas.addEventListener("pointerdown", (e) => {
  if (!smallScreen) return;
  touchActive = true;
  updateTouchDirFromEvent(e);
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("pointermove", (e) => {
  if (!smallScreen || !touchActive) return;
  updateTouchDirFromEvent(e);
  e.preventDefault();
}, { passive: false });

window.addEventListener("pointerup", () => {
  if (!smallScreen) return;
  touchActive = false;
  touchDir = 0;
});
window.addEventListener("pointercancel", () => {
  if (!smallScreen) return;
  touchActive = false;
  touchDir = 0;
});

window.addEventListener("keydown", e => {
  keys[e.code] = true;
});
window.addEventListener("keyup", e => {
  keys[e.code] = false;
});

// Trees / Obstacles
function getClusterParams(timeSec) {
  const extra = Math.min(Math.floor(timeSec / 5), 7);

  if (smallScreen) {
    return {
      base: MOBILE_CLUSTER_BASE,
      extraCap: Math.min(extra, MOBILE_CLUSTER_EXTRA_CAP),
      randMax: MOBILE_CLUSTER_RAND_MAX
    };
  }
  return {
    base: DESKTOP_CLUSTER_BASE,
    extraCap: Math.min(extra, DESKTOP_CLUSTER_EXTRA_CAP),
    randMax: DESKTOP_CLUSTER_RAND_MAX
  };
}

function spawnTreeCluster() {
  const t = currentTimeSec;
  const { base, extraCap, randMax } = getClusterParams(t);
  const rand = Math.floor(Math.random() * (randMax + 1));
  const count = base + extraCap + rand; // mobile = always 1

  const baseX = Math.random() * (canvas.width - 160) + 80;
  const spread = 60 + extraCap * 15;

  for (let i = 0; i < count; i++) {
    obstacles.push({
      x: baseX + (Math.random() - 0.5) * spread,
      y: canvas.height + 50 + Math.random() * 50,
      emoji: "üå≤",
      size: 50,
      speed: getTreeSpeed()
    });
  }
}

function collided(player, obstacle) {
  const dx = player.x - obstacle.x;
  const dy = player.y - obstacle.y;
  return Math.sqrt(dx * dx + dy * dy) < 50;
}

// Snow dust (kept minimal)
function spawnSnowDustForPlayer(player) {
  if (player.crashed) return;
  const lastX = player.lastX ?? player.x;
  const dx = player.x - lastX;
  player.lastX = player.x;
  const intensity = Math.abs(dx) > 0.5 ? 3 : 1;
  for (let i = 0; i < intensity; i++) {
    snowParticles.push({
      x: player.x + (Math.random() - 0.5) * 18,
      y: player.y + Math.random() * 2,
      vx: (Math.random() - 0.5) * 40,
      vy: -60 - Math.random() * 160,
      life: 0.3 + Math.random() * 0.3,
      size: 2 + Math.random() * 2
    });
  }
}
function updateSnowDust(dt) {
  for (let i = snowParticles.length - 1; i >= 0; i--) {
    const p = snowParticles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) snowParticles.splice(i, 1);
  }
}
function drawSnowDust() {
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  snowParticles.forEach(p => ctx.fillRect(p.x, p.y, p.size, p.size));
  ctx.restore();
}

// Game Over / Restart
function endGame() {
  if (gameOver) return;
  gameOver = true;
  pauseMusic();
  restartMenuMusic();
  const meters = Math.round(freezeTimeSec * 10);
  resultTextEl.textContent = `you made it ${meters} meters`;
  gameOverOverlay.classList.add("visible");
}

function restartGame() {
  gameStarted = false;
  gameOver = false;
  runEnded = false;
  transitioningToGame = false;

  pauseMusic();
  playMenuMusic();

  startTime = null;
  currentTimeSec = 0;
  freezeTimeSec = 0;
  pendingGameOverTime = 0;

  paused = false;
  pausedAt = 0;
  pausedAccum = 0;

  spawnTimer = 0;
  lastFrameTime = null;

  obstacles = [];
  snowParticles = [];

  touchActive = false;
  touchDir = 0;

  [skier, snowboarder].forEach(p => {
    p.emoji = p.baseEmoji;
    p.crashed = false;
    p.crashMeters = 0;
    p.lastX = null;
    p.facingRight = false;
    p.y = getTargetY();
  });

  hudDistanceEl.textContent = "DISTANCE: 0m";
  startScreen.style.display = "flex";
  gameOverOverlay.classList.remove("visible");
  applyMenuForScreenSize();
}
restartBtn.onclick = () => { playClickSfx(); restartGame(); };

// Transition
function easeOutBack(t) {
  const c1 = 0.2;
  const c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function startPixelTransition(onDone) {
  pixelCanvas.width = window.innerWidth;
  pixelCanvas.height = window.innerHeight;
  pixelCanvas.style.display = "block";

  const stripeHeight = Math.ceil(pixelCanvas.height * 0.10);
  const stripeCount = Math.ceil(pixelCanvas.height / stripeHeight);
  const stripeDuration = 300;
  const stripeDelay = 80;

  let start = null;
  function animate(ts) {
    if (start === null) start = ts;
    const elapsed = ts - start;

    pctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
    pctx.fillStyle = "#D9E5F4";

    for (let i = 0; i < stripeCount; i++) {
      const local = elapsed - i * stripeDelay;
      if (local <= 0) continue;
      const progress = Math.min(local / stripeDuration, 1);
      const w = pixelCanvas.width * progress;
      const y = i * stripeHeight;
      pctx.fillRect(0, y, w, stripeHeight);
    }

    const totalDuration = (stripeCount - 1) * stripeDelay + stripeDuration;
    if (elapsed < totalDuration) requestAnimationFrame(animate);
    else {
      if (onDone) onDone();
      pixelCanvas.style.display = "none";
    }
  }
  requestAnimationFrame(animate);
}

// Main loop
function update(timestamp) {
  drawSolidBackground();

  if (lastFrameTime === null) lastFrameTime = timestamp;
  let dt = (timestamp - lastFrameTime) / 1000;
  if (dt > 0.05) dt = 0.05;
  lastFrameTime = timestamp;

  if (!startTime && gameStarted) startTime = timestamp;
  if (runEnded) currentTimeSec = freezeTimeSec;
  else if (!paused && gameStarted) currentTimeSec = (timestamp - startTime - pausedAccum) / 1000;

  if (introSliding) {
    const elapsed = timestamp - introSlideStart;
    const t = Math.min(elapsed / introSlideDuration, 1);
    const eased = easeOutBack(t);
    const startY = -150;
    const targetY = getTargetY();
    activePlayers.forEach(p => { p.y = startY + (targetY - startY) * eased; });
    if (t >= 1) {
      introSliding = false;
      activePlayers.forEach(p => { p.y = targetY; });
    }
  }

  if (gameStarted && !gameOver) {
    if (!runEnded && !paused) {
      const p = activePlayers[0];
      if (p && !p.crashed) {
        let dir = smallScreen ? touchDir : ((keys["ArrowLeft"] ? -1 : 0) + (keys["ArrowRight"] ? 1 : 0));
        if (dir > 0) p.facingRight = true;
        else if (dir < 0) p.facingRight = false;

        const speed = (p === skier) ? getSkiSpeed() : getSnowboardSpeed();
        p.x = Math.max(40, Math.min(canvas.width - 40, p.x + dir * speed * dt));
      }
    }

    if (!paused) {
      activePlayers.forEach(spawnSnowDustForPlayer);
      updateSnowDust(dt);

      if (!runEnded) {
        const baseSpawn = smallScreen ? MOBILE_SPAWN_BASE : DESKTOP_SPAWN_BASE;
        const rampSpawn = smallScreen ? MOBILE_SPAWN_RAMP : DESKTOP_SPAWN_RAMP;
        const capSpawn  = smallScreen ? MOBILE_SPAWN_CAP  : DESKTOP_SPAWN_CAP;

        const spawnProbPerFrameAt60fps = Math.min(baseSpawn + currentTimeSec * rampSpawn, capSpawn);
        const clustersPerSecond = spawnProbPerFrameAt60fps * 60;

        spawnTimer += dt * clustersPerSecond;
        while (spawnTimer >= 1) {
          spawnTreeCluster();
          spawnTimer -= 1;
        }
      }

      obstacles.forEach(o => { o.y -= o.speed * dt; });
      obstacles = obstacles.filter(o => o.y > -80);

      activePlayers.forEach(p => {
        if (p.crashed) p.y -= getCrashSlideSpeed() * dt;
      });
    }

    drawSnowDust();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.font = "50px serif";
    obstacles.forEach(o => ctx.fillText(o.emoji, o.x, o.y));

    activePlayers.forEach(p => {
      ctx.font = `${p.size}px serif`;
      if (p.facingRight && !p.crashed) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.scale(-1, 1);
        ctx.fillText(p.emoji, 0, 0);
        ctx.restore();
      } else {
        ctx.fillText(p.emoji, p.x, p.y);
      }
    });

    if (!runEnded && !paused) {
      obstacles.forEach(o => {
        activePlayers.forEach(p => {
          if (p.crashed) return;
          if (collided(p, o)) {
            p.crashed = true;
            p.emoji = "üí•";
            playExplosion();
            runEnded = true;
            freezeTimeSec = currentTimeSec;
            pendingGameOverTime = timestamp + 1000;
          }
        });
      });
    }

    if (runEnded && !gameOver && timestamp >= pendingGameOverTime) endGame();

    const metersNow = (runEnded ? freezeTimeSec : currentTimeSec) * 10;
    hudDistanceEl.textContent = `DISTANCE: ${metersNow.toFixed(0)}m`;
  }

  requestAnimationFrame(update);
}

requestAnimationFrame(update);
playMenuMusic();
</script>
</body>
</html>
